"""
计算机的硬件组成：
    主板  固化（寄存器，是直接和cpu进行交互的一个硬件）
    CPU  中央处理器：计算（数字计算和逻辑计算）和控制（控制所有硬件协调工作）
    存储 硬盘 内存
    输入设备 键盘 鼠标 话筒
    输出设备 显示器 音响 打印机

早期的计算机是以计算为核心的。现在的计算机是以存储为核心的

计算机的发展过程：
    电子管计算机 耗电 体积大 散热量高
    晶体管计算机
    白色大头计算机 集成电路计算机
    大型集成电路计算机：
    甚大型集成电路计算机


计算机的操作系统：
    操作系统是一个软件，是一个能直接操作硬件的一个软件
    微软研发的windows操作系统
    人工时代：穿孔卡带
    脱机时代：完全将人和机器分开
    单道批处理系统：内存中只允许存放一道作业
    多道批处理系统：内存中只允许存放多道作业
    分时系统：将cpu的执行时间划分时间片，每个程序以时间片为单位去执行
    实时系统： 少见 用于军事和工业生产上

    目标：让用户使用轻松，高可用，低耦合
        封装了所有硬件的接口，使用户更方便的使用
        对于计算机内的所有资源，进行一个合理的调度和分配

计算机语言发展过程：
    机器语言 0／1
    汇编语言 指令 add n,m, 命令形式的
    高级语言 面向过程语言（c），面向对象语言（python，java, c++)

os:
    Dos系统 纯编程系统 单用户单任务
    windows系统 但用户多任务
    unix系统 多用户多任务

关于进程：
    .sh shell脚本文件
    .out linux中的可执行文件
    .bat 批处理脚本文件
    .lib 库文件
    .dll 库
    .exe 可执行文件

    进程：正在执行的程序 是程序执行过程中的依稀 指令，数据集等的集合
        也可以叫做程序的一次执行过程，是一个动态的概念

    进程的组成： 代码段，数据段，PCB:进程控制块

    进程的三大基本状态：
        就绪状态： 已经获得了运行所需要的所有资源，除了CPU
        执行状态：已经获得了所有资源包括cpu，处于正在执行的状态
        阻塞状态：因为各种原因，进程放弃了cpu，导致进程无法继续执行，此时进程处于内存中，继续等待获取cpu

        一个特殊状态：挂起状态：因为各种原因，进程放弃了cpu， 导致进程无法继续执行，此时进程被踢出内存

multiprocessing 内置模块 用于多进程编程， Process from multiprocessing import Process

并行：指两件或多件事情，在同一时间点开始执行
并发：指两件或多件事情，在同一时间间隔内同时执行
同步：某一个任务的执行必须依赖另一个任务的返回结果
异步：某一个任务的执行 不需要依赖另一个任务的返回，只需要告诉另一个任务一声
阻塞：程序因为蕾丝IO等待，等待时间等无法继续执行
非阻塞：程序遇到类似IO操作时，不再阻塞等待，如果没有即使处理IO,就报错活着跳过

进程的方法或属性：
    start() 开启一个子进程
    join（）异步变同步，让父进程等待子进程执行结束，再继续执行
    is_alive() 判断进程是否活着
    terminate() 杀死进程

    name: 子进程的名字
    pid：子进程的pid
    daemon：设置进程为守护进程，给一个True代表为守护进程，默认为False，不是守护进程

守护进程：
    随着父进程的代码执行完毕就结束（重点：代码执行！！完毕）
    守护进程不能创建子进程
    守护进程必须在start之前设置


IPC--进程间通信：
    锁机制：为了多进程通信时，保护数据的安全心
        l = Lock()
        l.acquire() 获得锁（其他进程不能访问）
        l.release() 释放锁（其他进程可以访问）

    信号机制：
        sem = Semaphore(n)
        n:初始化的时候一把锁配几把钥匙，int
        l.acquire()
        l.release()
        信号量机制比锁机制多了一个计数器，这个计数器用来记录当前剩余几把钥匙，计数器为0，表示当前没有钥匙，acquir()处于阻塞状态
        acquire一次 计数器内部减1，release一次就+1

    时间机制：
        e = Event(0
        e.set() 设置is_set（）为True (非阻塞状态）
        e.clear() 设置is_set()为False（阻塞状态）
        e.wait() 判断is_set()的值 ，True:非阻塞，False：zuse
        e.is_set() 标志

    正常情况下，多进程之间无法直接通信，因为每个进程都有自己独立的内存空间

生产者消费者模型：
    主要是用于解耦：借助队列来实现生产者消费者模型
    栈：先进后出
    队列：先进先出

    import queue  # 不能进行多进程之间的数据传输
    from multiprocessing import Queue 借助Queue解决生产者消费者模型
        队列是安全的
        q = Queue(num)
        num: 队列的最大长度
        q.get() 阻塞等待获取数据，如果有数据直接获取，如果没有则阻塞等待
        q.put() 阻塞 如果可以继续往队列中放数据，就直接放，不能放就阻塞等待

        q.get_nowait() 不阻塞 如果有数据直接获取，没有数据就报错
        q.put_nowait() 不阻塞 如果可以继续往队列中放数据，就直接放，不能放就报错

    from multiprocessing import JoinableQueue 可连接的队列
        继承Queue，可以使用queue的方法
        多的方法：
        q.join() 用户生产者 接收消费者的返回结果，接收全部生产的数量，以便知道什么时候队列里的数据被消费完了
        q.task_done（） 每消费一个数据，就返回一个表示 返回结果 生产者就能获得当前消费者消费量多少个数据 没消费队列中的一个数据，就给join返回一个表示
    管道：
        from multiprocessing import Pipe
        con1, con2 = Pipe()
        管道是不安全的
        管道是用于多进程之间通信的一种方式，
        单进程中：
            con1发则con2收。con2发则con1收
        多进程中：
            父进程con1发，子进程的con2收，
        管道中的错误EOFError 腹肌 in 成如果关闭来发送端，子进程还继续接收，就会导致EOFError

进程间的内存共享
        from multiprocessing import Manager, Value
        m = manager()
        num = m.dict({}) num = m.list([])

进程池：（一个池子，里面有固定数量的进程，且处在待命状态，一旦有任务来，马上就有进程去处理
    开启进程需操作系统消耗大量的时间去管理它，大量的时间让cpu去调度它
    进程池会帮助程序员去管理池中的进程
    from multiprocessing import Pool
    p = Pool(os.cpu_count() + 1)

    进程池的三个方法：
        map(func, iterable)
        func: 进程池中进程执行的任务函数
        iterable：可迭代对象，是把可迭代对象中的每个元素一次传给任务函数当参数

        apply（func, args =()）同步的执行，也就是说池中的进程一个个的去执行任务
        func: 进程池中进程执行的任务函数
        args: 可迭代对象型的参数，是传给任务函数的参数
        同步处理任务，不需要close和join
        同步处理任务时, 进程池中所有进程都是普通进程（主进程需要等待其结束）

        apply_async(func, args=(), callback=None) 异步： 池中的进程一次性去执行任务
        func: 进程池中进程执行的任务函数
        args: 可迭代对象型的参数，是传给任务函数的参数
        callback：回调函数 当进程池中有进程处理完任务来，返回的结果可以交给回调函数，由回调函数进一步的处理，只有异步才有
        异步处理任务，要close和join
        异步处理任务时, 进程池中所有进程都是守护进程

        回调函数:
            进程的任务函数的返回值，被当成回调函数的形参接收到，以此进一步的处理操作
            回调函数是由主进程调用的，而不是子进程，子进程只负责把结果给回调函数

IPC: 管道 队列 （锁，信号量，事件）


"""