# 递归实现
"""
递归思想：
取出数组中第一个元素放到最后，即a[1]与a[n]交换，然后递归求a[n-1]的全排列

1）如果数组只有一个元素n=1，a={1} 则全排列就是{1}
2）如果数组有两个元素n=2，a={1,2} 则全排列是：
{2,1}--a[1]与a[2]交换。交换后求a[2-1]={2}的全排列，归结到1)
{1,2}--a[2]与a[2]交换。交换后求a[2-1]={1}的全排列，归结到1)
3）如果数组有三个元素n=3，a={1,2,3} 则全排列是
{{2,3},1}--a[1]与a[3]交换。后求a[3-1]={2,3}的全排列，归结到2）
{{1,3},2)--a[2]与a[3]交换。后求a[3-1]={1,3}的全排列，归结到2）
{{1,2},3)--a[3]与a[3]交换。后求a[3-1]={1,2}的全排列，归结到2）
把每一个元素都和第一个元素交换， 对后边的序列进行排序
二叉树
"""


def perm(n, begin, end):
    # print(n, begin, end)
    if begin >= end:
        print(n)
    else:

        i = begin
        for num in range(begin, end):
            n[num], n[i] = n[i], n[num]  # 交换第一个元素
            perm(n, begin+1, end)  # 对后面的序列惊醒排序（固定当前位置，再进行下一位的排列）
            n[num], n[i] = n[i], n[num]  # 交换后交换回去，不影响后续的序列（回溯交换还原，以共其他下降路径使用）


n = [1, 2, 3, 4]
perm(n, 0, len(n))
